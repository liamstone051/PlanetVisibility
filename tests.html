<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>OpenLayers Planet Zenith Rings</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@7.5.0/dist/ol.css" />
  <style>
    html, body, #map { margin: 0; height: 100%; }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 999;
      background: white;
      padding: 10px;
      font-family: sans-serif;
      max-height: 90vh;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="controls"></div>

  <script src="https://cdn.jsdelivr.net/npm/ol@7.5.0/dist/ol.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/astronomy-engine@2.1.19/astronomy.browser.min.js"></script>

  <script>
    // Create map
    const map = new ol.Map({
      target: 'map',
      layers: [
        new ol.layer.Tile({
          source: new ol.source.OSM()
        })
      ],
      view: new ol.View({
        center: ol.proj.fromLonLat([0, 0]),
        zoom: 2
      })
    });

    function timeToLong(lstHrs, gstHrs) {
    //   let diff = lstHrs - gstHrs;
    //   if (diff > 12) diff -= 24;
    //   if (diff < -12) diff += 24;
      return (lstHrs - gstHrs) * 15;
    }

    function zenithLocator(bodyEnum) {
      const now = new Date();
      const observer = new Astronomy.Observer(0, 0, 0);
      const equ = Astronomy.Equator(bodyEnum, now, observer, true, true);
      const gst = Astronomy.SiderealTime(now);
      const lon = timeToLong(equ.ra, gst);
      const lat = equ.dec;
      return { lat, lon };
    }

    function unwrapCoords(coords) {
        const out = [coords[0].slice()];     // deep‑copy first point
        for (let i = 1; i < coords.length; i++) {
            let [lon,  lat ] = coords[i];
            let [prevLon]    = out[i - 1];
            let diff = lon - prevLon;

            if (diff < -180) lon += 360;       // crossed  +180 → -180  (eastward)
            if (diff >  180) lon -= 360;       // crossed  -180 → +180  (westward)

            out.push([lon, lat]);
        }
        return out;
        }

        /* ‑‑‑ helper: wrap back to ±180 just before projection ‑‑‑ */
    function wrapLon(lon) {
        return ((lon + 180) % 360 + 360) % 360 - 180;
    }

    function createCircleCoords(centerLonRaw, centerLat, radiusDeg, steps = 64) {
        const lonWrapped = wrapLon(centerLonRaw);           // in ±180°
        const shift      = centerLonRaw - lonWrapped;       // how much we’ll shift back
        let coords = turf.circle([lonWrapped, centerLat],
                                radiusDeg,
                                { steps, units: 'degrees' })
                        .geometry.coordinates[0];
        coords = coords.map(([lon, lat]) => [lon + shift, lat]);
        const [fLon, fLat] = coords[0];
        const [lLon, lLat] = coords[coords.length - 1];
        if (fLon !== lLon || fLat !== lLat) coords.push([fLon, fLat]);

        return coords;
    }
    function clampLat(lat) {
        const MAX = 85.05112878;          // Mercator ceiling
        return Math.max(-MAX, Math.min(MAX, lat));
    }

    function createRingFeature(coords, strokeColor, fillColor) {
        const unwrapped = unwrapCoords(coords);      // keep it continuous
        const olCoords = unwrapped.map(([lon, lat]) =>
            ol.proj.fromLonLat([lon, clampLat(lat)])    // normalise only at the end
        );
        const polygon = new ol.geom.Polygon([olCoords]);
        const feature = new ol.Feature(polygon);
        feature.setStyle(new ol.style.Style({
            stroke: new ol.style.Stroke({ color: strokeColor, width: 2 }),
            fill:   new ol.style.Fill  ({ color: fillColor })
        }));
        return feature;
    }

    (function debugOneRing () {
    const { lat, lon } = zenithLocator(Astronomy.Body.Jupiter);
    const raw = createCircleCoords(lon, lat, 20, 36);   // 36 points = 10° steps
    const longs = raw.map(c => c[0]);
    console.table(longs.slice(0, 15));                  // first 15 longitudes
    console.log('min lon:', Math.min(...longs),
                'max lon:', Math.max(...longs));
    })();
    // Define planet list and names
    const planets = [
      Astronomy.Body.Mercury,
      Astronomy.Body.Venus,
      Astronomy.Body.Mars,
      Astronomy.Body.Jupiter,
      Astronomy.Body.Saturn,
      Astronomy.Body.Uranus,
      Astronomy.Body.Neptune,
      Astronomy.Body.Pluto,
      Astronomy.Body.Moon
    ];

    const planetNames = {
      [Astronomy.Body.Mercury]: 'Mercury',
      [Astronomy.Body.Venus]: 'Venus',
      [Astronomy.Body.Mars]: 'Mars',
      [Astronomy.Body.Jupiter]: 'Jupiter',
      [Astronomy.Body.Saturn]: 'Saturn',
      [Astronomy.Body.Uranus]: 'Uranus',
      [Astronomy.Body.Neptune]: 'Neptune',
      [Astronomy.Body.Pluto]: 'Pluto',
      [Astronomy.Body.Moon]: 'Moon'
    };

    const ringDegrees = [89.9, 80, 70, 60, 50, 40, 30, 20, 10];

    // Color palettes
    const mercuryCols = ["#e8e0d8","#d8cfc3","#c8beb0","#b8ae9d","#a8988a","#948374","#7f6d5f","#69594c","#53443a"];
    const venusCols   = ["#fff8ef","#fde8d6","#facfb9","#f9b999","#f5a574","#e98d5a","#d57646","#b85c37","#9f4a2e"];
    const marsCols    = ["#f7dad4","#f1a69d","#e76b61","#d84d44","#bf382f","#a32f27","#85261d","#671b14","#4b130d"];
    const jupiterCols = ["#f4b08a","#e49063","#d8743d","#c55a27","#aa451f","#8e371a","#712c15","#55200f","#3a140a"];
    const saturnCols  = ["#fbeec1","#fae4a1","#f6d874","#ebb847","#d9992e","#d28d26","#c97e1f","#bc7018","#ae6010"];
    const uranusCols  = ["#e9fcf9","#c5f2ed","#a2e8e3","#7eddd7","#5bd2cb","#45bec2","#32aab2","#258e97","#1a737c"];
    const neptuneCols = ["#e2f0ff","#badcff","#91c7ff","#67b2ff","#499cf0","#3b87d9","#2d72c2","#1f5daa","#16498f"];
    const plutoCols   = ["#f0f4fb","#d7dfee","#c1cade","#abb5ce","#969fbe","#828aaf","#6e769f","#5a628f","#464f7f"];
    const moonCols    = ["#f4f4f4","#dfe0e2","#c8cad0","#b2b4ba","#9c9ea6","#858890","#6f727a","#5a5c63","#46474d"];

    const palettes = {
      Mercury: mercuryCols,
      Venus: venusCols,
      Mars: marsCols,
      Jupiter: jupiterCols,
      Saturn: saturnCols,
      Uranus: uranusCols,
      Neptune: neptuneCols,
      Pluto: plutoCols,
      Moon: moonCols
    };

    const planetCenters = {};
    const planetLayers = {};

    planets.forEach(bodyEnum => {
      const name = planetNames[bodyEnum];
      const { lat, lon } = zenithLocator(bodyEnum);
      planetCenters[name] = { lat, lon };
    });

    for (const [planet, center] of Object.entries(planetCenters)) {
      const colors = palettes[planet];
      if (!colors) continue;

      const source = new ol.source.Vector();
      const layer = new ol.layer.Vector({ source });
      ringDegrees.forEach((deg, i) => {
        const coords = createCircleCoords(center.lon, center.lat, deg, 64);
        const stroke = colors[i];
        const fill = `rgba(${parseInt(stroke.slice(1,3),16)},${parseInt(stroke.slice(3,5),16)},${parseInt(stroke.slice(5,7),16)},0.3)`;
        const feature = createRingFeature(coords, stroke, fill);
        source.addFeature(feature);
      });

      planetLayers[planet] = layer;
      map.addLayer(layer);
    }

    // Create checkboxes
    const controlDiv = document.getElementById('controls');
    Object.keys(planetLayers).forEach(planet => {
      const id = `chk_${planet}`;
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.id = id;
      checkbox.checked = true;

      const label = document.createElement('label');
      label.htmlFor = id;
      label.textContent = planet;

      const br = document.createElement('br');
      controlDiv.appendChild(label);
      controlDiv.appendChild(checkbox);
      controlDiv.appendChild(br);

      checkbox.addEventListener('change', e => {
        planetLayers[planet].setVisible(e.target.checked);
      });
    });
  </script>
</body>
</html>
